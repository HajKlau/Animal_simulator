1. Funkcja toLower
string toLower(const string& str) {
    string lowerStr;
    lowerStr.reserve(str.size());
    for (char c : str) {
        lowerStr += tolower(c);
    }
    return lowerStr;
}

Opisując funkcję toLower() na rozmowie o pracę, skoncentruj się na jej celu, sposobie działania oraz zastosowaniach. Oto przykład takiego opisu:
Cel funkcji:
"Funkcja toLower() została zaprojektowana do konwersji każdego znaku w podanym ciągu znaków (string) na małą literę. Jest to podstawowa funkcjonalność używana w wielu miejscach naszego symulatora zwierząt, na przykład przy porównywaniu nazw zwierząt, aby zapewnić niezależność od wielkości liter. Dzięki temu, niezależnie od tego, jak użytkownik wprowadzi dane, nasz system traktuje je w spójny sposób."
Sposób działania:
"Funkcja iteruje przez każdy znak w ciągu znaków wejściowym, używając pętli for. Dla każdego znaku, używa standardowej funkcji bibliotecznej tolower(), która konwertuje literę na jej mały odpowiednik, jeśli jest to litera wielka. Zmienione znaki są dodawane do nowego ciągu znaków lowerStr, który na początku funkcji został zarezerwowany, aby miał odpowiednią pojemność. To optymalizuje działanie przez minimalizację liczby realokacji pamięci."
Zastosowania:
"Konwersja ciągów znaków na małe litery jest szeroko stosowana w aplikacjach wymagających normalizacji danych tekstowych dla celów porównywania, sortowania, czy wyszukiwania. W naszym symulatorze zwierząt, jest kluczowa dla zapewnienia, że interakcje z użytkownikiem - jak wprowadzanie nazw zwierząt - są elastyczne względem formatowania i nie powodują nieporozumień czy błędów logicznych."
Podsumowanie:
"Prezentując funkcję toLower() na rozmowie, chcę podkreślić moją umiejętność pisania czystego, efektywnego i ponownie używalnego kodu. Zwracam też uwagę na moje zrozumienie, jak drobne elementy techniczne, takie jak ta funkcja, wpływają na użytkownika końcowego i ogólną użyteczność aplikacji. To pokazuje, że moje podejście programistyczne koncentruje się nie tylko na spełnieniu technicznych wymagań, ale także na zapewnieniu najlepszego doświadczenia użytkownikowi."
Przedstawiając tę funkcję w ten sposób, pokazujesz, że jesteś programistą, który rozumie znaczenie drobnych detali w kodzie i potrafi je efektywnie wykorzystać dla poprawy jakości oprogramowania.

2. Funkcja getUserConfirmation
bool getUserConfirmation(const string &question) {
    string response;
    while(true) {
        cout << question << (" \033[1m(yes/no)\033[0m");
        cin >> response;
        string lowerResponse = toLower(response);

        if (lowerResponse == "yes") {
            return true;
        } else if (lowerResponse == "no"){
            return false;
        } else {
            cout << "\033[1m\033[31mPlease enter 'yes' or 'no'.\033[0m" << endl;
        }
    }
}

"Funkcja getUserConfirmation() została zaprojektowana do interakcji z użytkownikiem w celu uzyskania potwierdzenia akcji, przyjmując jako argument tekst pytania. Wykorzystuje standardowe strumienie wejścia/wyjścia z biblioteki <iostream> do komunikacji z użytkownikiem. Centralnym elementem funkcji jest nieskończona pętla while, która gwarantuje, że użytkownik będzie kontynuować otrzymywanie monitu, aż do podania odpowiedzi 'yes' lub 'no'.
Aby zapewnić niezawodność i odporność na błędy, funkcja wykorzystuje metodę toLower(), którą zdefiniowano osobno, do konwersji wszystkich liter na małe. Dzięki temu porównanie stringów jest niezależne od wielkości liter, co zwiększa użyteczność i elastyczność funkcji.
Zastosowano tutaj podstawowe techniki obsługi błędów poprzez prośbę o ponowne wprowadzenie danych, jeśli otrzymano nierozpoznane wejście. Jest to realizowane za pomocą prostego warunku if-else, który sprawdza znormalizowaną odpowiedź i odpowiednio reaguje.
Ważne jest również zwrócenie uwagi na użycie sekwencji escape do formatowania i kolorowania tekstu w terminalu. To pokazuje dbałość o doświadczenie użytkownika nawet w konsolowych aplikacjach, poprawiając czytelność i użytkowanie.
Technicznie, ta funkcja demonstruje umiejętność pracy ze strumieniami wejścia/wyjścia, pętlami, warunkami i stringami w C++. Przykład ten ilustruje także, jak można zaimplementować prostą, ale kluczową funkcjonalność w sposób, który jest zarówno użytkownikowi przyjazny, jak i technicznie solidny."
Prezentując funkcję w ten sposób, podkreślasz swoją zdolność do efektywnego wykorzystania podstawowych konstrukcji języka C++ oraz dbałości o szczegóły w kodzie, które mają bezpośredni wpływ na jakość interakcji użytkownika z aplikacją. Demonstrujesz także zrozumienie, jak ważne jest projektowanie z myślą o użytkowniku, nawet w tak fundamentalnych aspektach aplikacji.

1. Konstruktor
Animal(string type, string name, string colour, int growth, int happiness, int appearance, int strength, int satisfaction) : type(type), name(name), colour(colour) {
        features["growth"] = growth;
        features["happiness"] = happiness;
        features["appearance"] = appearance;
        features["strength"] = strength;
        features["satisfaction"] = satisfaction;
    }

"Ten konstruktor klasy Animal jest przykładem konstruktora parametrycznego, który umożliwia inicjalizację obiektu z określonymi wartościami dla wszystkich jego atrybutów. Przyjmuje on osiem parametrów: type, name, colour (typu string) oraz growth, happiness, appearance, strength, satisfaction (typu int). Pierwsze trzy parametry (type, name, colour) są inicjalizowane bezpośrednio za pomocą listy inicjalizacyjnej, co jest zalecaną praktyką dla efektywnej inicjalizacji, ponieważ odbywa się to przed wejściem do ciała konstruktora.
Natomiast pozostałe pięć parametrów (growth, happiness, appearance, strength, satisfaction) są użyte do inicjalizacji mapy features w ciele konstruktora. Mapa features jest strukturą danych używaną do przechowywania i zarządzania różnymi cechami zwierzęcia w dynamiczny sposób, co umożliwia łatwe dodawanie lub modyfikowanie cech bez potrzeby zmiany definicji klasy. Wykorzystanie mapy w tym kontekście pokazuje, jak można efektywnie zarządzać zmiennymi cechami obiektu w zorientowanym obiektowo podejściu do programowania.
Ogólnie rzecz biorąc, ten konstruktor demonstruje wykorzystanie listy inicjalizacyjnej dla prostych inicjalizacji oraz wykorzystanie ciała konstruktora dla bardziej złożonych operacji inicjalizacyjnych, takich jak ustawienie wartości w mapie. To pokazuje dobry balans pomiędzy efektywnością inicjalizacji a elastycznością w zarządzaniu stanem obiektu."


2. Matoda performAction
void performAction(const string& action) {
        if (action == "eat") {
            features["growth"] += 1;
            cout << "\033[1mPerformed: " << action << ", " << name << " now has " << features["growth"] << " growth" << "\033[0m" << endl;
        } else if (action == "play") {
            features["happiness"] += 1;
            cout << "\033[1mPerformed: " << action << ", " << name << " now has " << features["happiness"] << " happiness" << "\033[0m" <<  endl;
        } else if (action == "wash") {
            features["appearance"] += 1;
            cout << "\033[1mPerformed: " << action << ", " << name << " now has " << features["appearance"] << " appearance" << "\033[0m" << endl;
        } else if (action == "sleep") {
            features["strength"] += 1;
            cout << "\033[1mPerformed: " << action << ", " << name << " now has " << features["strength"] << " strength" << "\033[0m" << endl;
        } else if (action == "stroke") {
            features["satisfaction"] += 1;
            cout << "\033[1mPerformed: " << action << ", " << name << " now has " << features["satisfaction"] << " satisfaction" << "\033[0m" << endl;
        } else {
            cout << "\033[31m\033[1mUnknown action: " << "'" << action << "'. No changes made.\033[0m" << endl;
        }   
    }

Funkcja performAction jest metodą klasy Animal, która służy do symulacji różnych działań wykonywanych przez zwierzę, takich jak jedzenie (eat), zabawa (play), mycie (wash), spanie (sleep) oraz głaskanie (stroke). Funkcja ta przyjmuje jeden parametr typu string, który reprezentuje akcję do wykonania. Na podstawie tego parametru, funkcja aktualizuje odpowiednie cechy zwierzęcia w mapie features, które przechowują kluczowe metryki, takie jak wzrost, szczęście, wygląd, siła oraz zadowolenie.
Każda akcja zwiększa określoną cechę o jeden punkt. Na przykład, akcja eat zwiększy wartość growth (wzrost), a akcja play zwiększy happiness (szczęście). Po wykonaniu akcji, funkcja wyświetla komunikat w konsoli, informujący o wykonanej akcji oraz aktualnej wartości zmodyfikowanej cechy.
W przypadku podania akcji, która nie jest obsługiwana (czyli nie znajduje się w zdefiniowanym zestawie akcji), funkcja wyświetla komunikat o nieznanej akcji, informując użytkownika, że żadne zmiany nie zostały dokonane.
Ta metoda demonstruje zastosowanie instrukcji warunkowych do obsługi różnych scenariuszy oraz zarządzanie stanem obiektu poprzez aktualizację wartości w mapie. Ponadto, używa ona dynamicznego dostępu do elementów mapy i prezentuje efektywny sposób informowania użytkownika o wyniku wykonanych operacji. Jest to przykład eleganckiego sposobu modelowania zachowań obiektów w programowaniu zorientowanym obiektowo."
Do technicznego opisu funkcji performAction można dodać następujące informacje, które skupiają się na bardziej szczegółowych aspektach implementacji oraz podejściu programistycznym:
Metoda performAction zaimplementowana jest w klasie Animal, co oznacza, że każdy obiekt typu Animal posiada zdolność do wykonania zdefiniowanych w niej akcji. Przyjmowany parametr typu std::string reprezentuje akcję do wykonania na obiekcie. Wewnątrz funkcji używamy instrukcji warunkowej if-else, aby sprawdzić, jaką akcję należy wykonać, i odpowiednio zaktualizować stan obiektu.
Zarządzanie stanem obiektu odbywa się poprzez modyfikację mapy features, która przechowuje kluczowe atrybuty zwierzęcia w parach klucz-wartość. Kluczem jest nazwa cechy (std::string), a wartością jej aktualny poziom (int). Mapa features umożliwia dynamiczne zarządzanie różnymi atrybutami zwierzęcia w sposób uporządkowany i łatwo dostępny.
Aktualizacja wartości w mapie features odbywa się poprzez operator [], który pozwala na dostęp do wartości po kluczu. Następnie, inkrementujemy wartość wybranej cechy, co odzwierciedla efekt wykonania akcji przez zwierzę.
Po zaktualizowaniu mapy features, metoda wyświetla informacje o wykonanej akcji oraz nowej wartości cechy za pomocą std::cout. Używa formatowania tekstu (takiego jak \033[1m dla pogrubienia) do poprawy czytelności wyjścia.
W przypadku podania akcji, która nie jest zdefiniowana w metodzie, wyświetlany jest komunikat o błędzie, co informuje użytkownika o niepoprawnym wejściu bez wprowadzania zmian w stanie obiektu.
Podczas implementacji metody zastosowano podejście zapewniające rozszerzalność – dodanie nowych akcji wymaga jedynie rozszerzenia instrukcji warunkowej. Jest to również przykład zastosowania enkapsulacji, ponieważ metoda operuje na wewnętrznym stanie obiektu, nie ujawniając szczegółów implementacji na zewnątrz klasy.
W skrócie, performAction demonstruje kluczowe zasady programowania obiektowego, takie jak enkapsulacja, abstrakcja i zarządzanie stanem, oraz wykorzystuje standardowe elementy języka C++, w tym kontenery STL (Standard Template Library), instrukcje warunkowe i operacje na łańcuchach znaków."

3. Metoda displayFeatures
void displayFeatures() {
        cout << "\033[32m\033[1m" << name << " is a " << colour << " " << type << " with the following features:\033[0m " << endl;
        for (const auto& feature : features) {
            cout << feature.first << ": " << feature.second << endl;
        }
    }

Opisując metodę displayFeatures na rozmowie o pracę, można podkreślić jej rolę w interfejsie użytkownika, jej implementację oraz znaczenie w kontekście enkapsulacji i designu aplikacji. Oto przykład takiego opisu:
Funkcjonalność:
Metoda displayFeatures w klasie Animal służy do wyświetlania szczegółów dotyczących zwierzęcia, w tym jego imienia, koloru, typu oraz zestawu cech, takich jak wzrost, szczęście, wygląd, siła i zadowolenie. Jest to metoda kluczowa dla interakcji użytkownika z symulatorem, ponieważ zapewnia szybki i czytelny sposób na ocenę stanu i postępów zwierzęcia. Wyświetlane informacje są szczególnie ważne dla użytkownika, który chce monitorować rozwój swojego wirtualnego pupila."
Techniczne aspekty:
Z technicznego punktu widzenia, displayFeatures demonstruje zastosowanie iteracji po mapie unordered_map, gdzie kluczem jest nazwa cechy, a wartością - jej aktualna wielkość. Metoda ta jest prostym, ale efektywnym przykładem prezentacji danych użytkownikowi. Użycie kodów ANSI do formatowania tekstu, jak tu widać, pozwala na wyróżnienie kluczowych informacji, co sprawia, że dane są nie tylko czytelne, ale i estetycznie prezentowane."
Rola w aplikacji:
W kontekście całości aplikacji, displayFeatures odgrywa kluczową rolę w zapewnieniu interaktywności i angażowania użytkownika. Metoda ta, choć technicznie prosta, jest podstawowym narzędziem w procesie informowania użytkownika o stanie gry i stanowi przykład, jak ważna jest przemyślana prezentacja danych w aplikacjach interaktywnych. Implementacja tej metody świadczy również o zastosowaniu enkapsulacji – zewnętrzne komponenty systemu otrzymują dostęp do wewnętrznych danych klasy Animal w kontrolowany sposób, co jest zgodne z zasadami bezpiecznego projektowania oprogramowania."
Podsumowanie:
Prezentacja metody displayFeatures na rozmowie kwalifikacyjnej podkreśla nie tylko umiejętność techniczną w implementacji funkcji wyświetlającej dane, ale także zrozumienie znaczenia takich metod w kontekście UX/UI oraz ogólnej architektury aplikacji. Pokazuje to również umiejętność pracy z danymi w sposób, który jest zarówno funkcjonalny, jak i estetycznie przyjemny dla użytkownika."
Opisując tę metodę, podkreślasz swoje zrozumienie dla szczegółów implementacyjnych oraz dla szerszego kontekstu użyteczności i projektowania aplikacji, co jest kluczowe dla pracodawców szukających doświadczonych programistów.

4. Metoda hasReachedAdulthood
hasReachedAdulthood() const {
        for (const auto& feature : features) {
            if (feature.second < 5) {
                return false;
            }
        } 
        return true;
    }


Opisując metodę hasReachedAdulthood() na rozmowie o pracę, skup się na jej znaczeniu w kontekście biznesowym aplikacji, sposobie implementacji oraz jej wpływie na logikę aplikacji. Oto przykład takiego opisu:
Funkcjonalność:
"Metoda hasReachedAdulthood() w klasie Animal służy do określenia, czy zwierzę osiągnęło dorosłość, bazując na zestawie predefiniowanych cech. W naszym symulatorze, dorosłość jest definiowana jako osiągnięcie przez zwierzę poziomu 5 we wszystkich kluczowych cechach życiowych, takich jak wzrost, szczęście, czy siła. Jest to kluczowa funkcjonalność umożliwiająca symulację progresji i rozwoju zwierzęcia w grze."
Techniczne aspekty:
"Technicznie, metoda iteruje przez mapę unordered_map zawierającą cechy zwierzęcia i ich aktualne wartości, sprawdzając, czy każda z cech osiągnęła wymagany próg. Użycie pętli for w połączeniu z konstruktem auto pozwala na efektywne i zwięzłe przeszukanie struktury danych bez konieczności bezpośredniego odwoływania się do typów danych. Ta metoda jest przykładem efektywnego zastosowania standardowych bibliotek C++ do realizacji konkretnej funkcjonalności biznesowej."
Rola w aplikacji:
"W szerszym kontekście aplikacji, hasReachedAdulthood() pełni ważną rolę w decydowaniu o możliwych interakcjach użytkownika ze zwierzęciem oraz w określaniu momentu, gdy zwierzę jest gotowe na nowe wyzwania lub etapy w symulatorze. Osiągnięcie dorosłości przez zwierzę może otwierać nowe opcje rozgrywki, nagrody dla gracza, czy też poziomy trudności. Metoda ta wpływa bezpośrednio na mechanikę gry i angażowanie użytkownika poprzez wprowadzenie wyraźnych celów i osiągnięć."
Podsumowanie:
"Prezentując metodę hasReachedAdulthood() na rozmowie o pracę, podkreślam zrozumienie dla zastosowania logicznych operacji w kontekście biznesowym aplikacji oraz umiejętność wykorzystania kolekcji i algorytmów standardowej biblioteki C++. Wskazuję również na moją zdolność do myślenia w kategoriach wpływu poszczególnych elementów logiki aplikacji na doświadczenie użytkownika i ogólną strukturę gry. Demonstruje to moje podejście do projektowania oprogramowania, które bierze pod uwagę zarówno aspekty techniczne, jak i potrzeby użytkownika końcowego."

7. Konstruktor AnimalSimulator

AnimalSimulator() : db(nullptr) {

        initializeDatabase();
        loadGameState();

        animalDescriptions = {
            {"mammals", "\033[1mMammals\033[0m are a diverse group of animals that share several key traits, such as hair or fur covering the body, the ability to give birth to live young and feed them with their mother's milk. Their advanced nervous systems allow for complex social behavior."},
            {"reptiles", "\033[1mReptiles\033[0m are cold-blooded animals with hard scales that inhabit a variety of environments around the world. They include snakes, lizards, crocodiles and turtles."},
            {"amphibians", "\033[1mAmphibians\033[0m are a unique group of cold-blooded animals that undergo metamorphosis from an aquatic larva with gills to an adult usually breathing atmospheric air. They are sensitive to changes in the environment, making them important indicators of ecosystem health."},
            {"birds", "\033[1mBirds\033[0m are warm-blooded animals characterized by the presence of feathers, a beak without teeth, and folding wings that in most cases allow flight."},
            {"fish", "\033[1mFish\033[0m are cold-blooded aquatic animals that have fins and breathe with gills. They inhabit a variety of aquatic environments, from freshwater to salty oceans."},
            {"arthropods", "\033[1mArthropods\033[0m are the most numerous group of animals on Earth, including insects, spiders, crustaceans and others. They are characterized by a segmented body, an external skeleton and paired, differentiated limbs."}
        };
        actions = {"eat", "play", "wash", "sleep", "stroke"};

Ten fragment kodu to definicja konstruktora klasy AnimalSimulator. Pozwala ona zainicjować obiekt klasy AnimalSimulator z określonymi początkowymi wartościami i stanem. Oto dokładne wyjaśnienie poszczególnych linii:
AnimalSimulator() : db(nullptr) { - to jest definicja konstruktora klasy AnimalSimulator. Część : db(nullptr) to lista inicjalizacyjna, która inicjalizuje wskaźnik db wartością nullptr, oznaczając, że na początku wskaźnik na obiekt bazy danych SQLite (sqlite3* db) jest pusty (nie wskazuje na żadny obiekt).
initializeDatabase(); - ta linia wywołuje metodę initializeDatabase, która jest odpowiedzialna za inicjalizację bazy danych, w tym otwarcie połączenia z bazą danych i utworzenie niezbędnych tabel, jeśli jeszcze nie istnieją.
loadGameState(); - wywołuje metodę loadGameState, która ma za zadanie wczytać zapisany stan gry z bazy danych i odtworzyć stan obiektów w programie na podstawie tych danych.
animalDescriptions = { ... }; - ta sekcja inicjalizuje mapę animalDescriptions, która przechowuje opisy różnych rodzajów zwierząt. Mapa jest inicjalizowana parami klucz-wartość, gdzie klucz to ciąg znaków reprezentujący kategorię zwierzęcia (np. "mammals", "reptiles"), a wartość to ciąg znaków opisujący tę kategorię. Sekwencje takie jak \033[1m i \033[0m służą do zmiany stylu tekstu w terminalu, np. do pogrubienia.
actions = {"eat", "play", "wash", "sleep", "stroke"}; - inicjalizuje wektor actions listą akcji, które można wykonać na zwierzętach w symulatorze. Każda akcja to ciąg znaków reprezentujący nazwę akcji.
Podsumowując, konstruktor klasy AnimalSimulator inicjalizuje wskaźnik bazy danych na nullptr, otwiera połączenie z bazą danych i tworzy tabele, jeśli jest to konieczne, wczytuje zapisany stan gry, inicjalizuje opisy zwierząt i dostępne akcje. Dzięki temu, kiedy tworzysz obiekt AnimalSimulator, jest on gotowy do użycia z odpowiednio skonfigurowaną bazą danych i zestawem danych niezbędnych do działania symulatora.
Wstęp do konstruktora:
"Konstruktor AnimalSimulator służy do inicjalizacji kluczowych składników aplikacji symulatora zwierząt. Jego głównym zadaniem jest przygotowanie środowiska symulacji, w tym ustawienie wskaźnika bazy danych na nullptr, co zapewnia, że program jest w stabilnym stanie przed nawiązaniem połączenia z bazą danych. To zabezpiecza aplikację przed potencjalnymi błędami związanymi z niezainicjalizowanym wskaźnikiem."
Inicjalizacja bazy danych:
"Następnie konstruktor wywołuje metodę initializeDatabase, która próbuje otworzyć połączenie z bazą danych SQLite. Użycie nullptr jako początkowej wartości wskaźnika db pozwala nam wyraźnie zidentyfikować, czy połączenie zostało pomyślnie nawiązane. Jest to istotne dla bezpieczeństwa aplikacji, gdyż zapobiega dostępowi do niezainicjalizowanej pamięci."
Ładowanie stanu gry:
"Po inicjalizacji bazy danych, konstruktor wywołuje loadGameState, co umożliwia wczytanie zapisanego stanu gry z bazy danych. Dzięki temu, jeśli symulator był wcześniej używany, użytkownik może kontynuować symulację od miejsca, w którym skończył."
Inicjalizacja danych aplikacji:
"Oprócz obsługi bazy danych, konstruktor inicjuje również słownik animalDescriptions, który zawiera opisy różnych typów zwierząt dostępnych w symulatorze. Jest to kluczowe dla interfejsu użytkownika, umożliwiając prezentację informacji o zwierzętach w atrakcyjny i edukacyjny sposób."
Wykorzystanie listy inicjalizacyjnej:
"Użycie listy inicjalizacyjnej, w tym przypadku : db(nullptr), to dobry przykład efektywnego wykorzystania możliwości C++. Pozwala na bezpośrednią inicjalizację członków klasy przed wejściem do ciała konstruktora. Jest to szczególnie użyteczne w przypadkach, gdy chcemy uniknąć niejednoznaczności i zapewnić, że nasz wskaźnik jest bezpiecznie zainicjalizowany na nullptr zanim zostanie użyty."
Podsumowanie:
"Konstruktor AnimalSimulator został zaprojektowany z myślą o bezpieczeństwie, elastyczności i łatwości rozszerzania aplikacji. Dzięki starannej inicjalizacji i zarządzaniu zasobami, symulator jest odporny na częste problemy związane z zarządzaniem pamięcią i bazami danych. To pokazuje, jak ważne jest przemyślane projektowanie konstruktorów w aplikacjach obiektowych."


8. Destruktor AnimalSimulator
  ~AnimalSimulator() {
        if (db) {
            sqlite3_close(db);
        }
    }

Ten fragment kodu przedstawia destruktor klasy AnimalSimulator. Destruktor jest specjalną funkcją w C++, która jest automatycznie wywoływana, gdy obiekt danej klasy jest niszczony, czyli na przykład gdy opuszcza zakres swojej widoczności, lub gdy jest jawnie usuwany za pomocą operatora delete.
Oto szczegółowe wyjaśnienie działania tego destruktora:
Sprawdzenie wskaźnika db: W pierwszej linii destruktora znajduje się instrukcja warunkowa if (db), która sprawdza, czy wskaźnik db do obiektu bazy danych SQLite jest różny od nullptr. W praktyce oznacza to, że destruktor sprawdza, czy połączenie z bazą danych zostało w ogóle nawiązane.
Zamknięcie połączenia z bazą danych: Jeżeli wskaźnik db wskazuje na obiekt bazy danych (czyli jeśli połączenie zostało nawiązane), instrukcja sqlite3_close(db); zostaje wykonana. Ta instrukcja zamyka połączenie z bazą danych SQLite, z którą obiekt db jest powiązany. Jest to ważne z punktu widzenia zarządzania zasobami systemowymi, ponieważ otwarte połączenia z bazą danych mogą zajmować cenne zasoby systemowe oraz utrzymywać zablokowane zasoby bazy danych.
Automatyczne działanie destruktora: Ponieważ destruktor jest wywoływany automatycznie podczas niszczenia obiektu AnimalSimulator, mechanizm ten zapewnia, że zasoby są zwalniane w odpowiednim momencie, co minimalizuje ryzyko wycieków pamięci oraz innych problemów związanych z niewłaściwym zarządzaniem zasobami.
Podsumowując, destruktor ~AnimalSimulator() dba o to, aby połączenie z bazą danych zostało zamknięte w odpowiednim momencie, zapewniając prawidłowe zarządzanie zasobami i unikanie wycieków pamięci. Jest to kluczowy element zarządzania zasobami w aplikacjach korzystających z baz danych, szczególnie w językach takich jak C++, gdzie programista jest odpowiedzialny za manualne zarządzanie pamięcią i zasobami systemowymi.


 9. Inicjalizacja bazy danych 
 void initializeDatabase() {
    int rc = sqlite3_open("/home/klahaj/nauka_programowania/Animal_simulator/game_state.db", &db);
    if (rc) {
        cerr << "Error opening SQLite database: " << sqlite3_errmsg(db) << endl;
        sqlite3_close(db);
        exit(1);
    }
Ten fragment kodu dotyczy metody initializeDatabase(), która jest częścią klasy AnimalSimulator w programie symulującym zachowanie zwierząt. Jego głównym celem jest inicjalizacja bazy danych SQLite, co umożliwia zapisywanie i odczytywanie stanu symulacji. Oto szczegółowy opis:
Otwarcie połączenia z bazą danych: Używamy funkcji sqlite3_open, przekazując jej ścieżkę do pliku bazy danych ("/home/klahaj/nauka_programowania/Animal_simulator/game_state.db") oraz wskaźnik na zmienną typu sqlite3* (&db). Funkcja ta próbuje otworzyć bazę danych znajdującą się pod podaną ścieżką. Jeśli baza danych nie istnieje, SQLite próbuje ją utworzyć.
Obsługa błędów: Zmienna rc przechowuje kod wyniku działania funkcji sqlite3_open. Jeżeli rc nie jest równy 0, oznacza to, że wystąpił błąd podczas otwierania bazy danych. W takim przypadku wykorzystujemy funkcję cerr do wyświetlenia komunikatu o błędzie. Funkcja sqlite3_errmsg(db) zwraca czytelny dla człowieka opis błędu, który wystąpił podczas ostatniej operacji na bazie danych.
Zamknięcie bazy danych i wyjście z programu: Jeśli otwarcie bazy danych się nie powiedzie, używamy funkcji sqlite3_close(db) do zamknięcia połączenia z bazą danych (jeśli zostało częściowo ustanowione) i zwolnienia zasobów. Następnie, wywołanie exit(1) powoduje zakończenie programu z kodem błędu 1, sygnalizując, że nie można kontynuować ze względu na problemy z bazą danych.
Podczas rozmowy o pracę, prezentując ten fragment kodu, warto podkreślić swoją znajomość obsługi błędów i bezpiecznego zarządzania zasobami, co jest kluczowe w tworzeniu niezawodnych i trwałych aplikacji. Można również wspomnieć o ważności właściwego zarządzania połączeniami z bazą danych, aby uniknąć wycieków pamięci i innych problemów z zasobami.

9. Tworzenie tabeli SQL
const char* sqlCreateTable = R"(
        CREATE TABLE IF NOT EXISTS GameStates (
            ID INTEGER PRIMARY KEY AUTOINCREMENT,
            Type TEXT NOT NULL,
            Name TEXT NOT NULL,
            Colour TEXT NOT NULL,
            Growth INTEGER,
            Happiness INTEGER,
            Appearance INTEGER,
            Strength INTEGER,
            Satisfaction INTEGER
        )
    )";

Ten fragment kodu to literał łańcuchowy w C++, który zawiera polecenie SQL do tworzenia tabeli w bazie danych SQLite. Polecenie to jest przypisane do stałej wskaźnikowej sqlCreateTable typu const char*. Oto szczegółowe wyjaśnienie składników tego fragmentu:
CREATE TABLE IF NOT EXISTS GameStates: Ta część polecenia SQL instruuje SQLite, aby utworzyła nową tabelę o nazwie GameStates, ale tylko w przypadku, gdy tabela o tej nazwie jeszcze nie istnieje. To zapobiega błędom lub konfliktom wynikającym z prób utworzenia tabeli, która już istnieje w bazie danych.
ID INTEGER PRIMARY KEY AUTOINCREMENT: Definiuje kolumnę ID jako klucz główny tabeli, co oznacza, że każdy wpis (rekord) w tabeli będzie miał unikalną wartość w tej kolumnie. INTEGER określa typ danych tej kolumny jako liczbowy. AUTOINCREMENT oznacza, że SQLite automatycznie przyzna każdemu nowemu rekordowi kolejną, wyższą wartość ID, począwszy od 1. Ułatwia to jednoznaczną identyfikację rekordów.
Type TEXT NOT NULL, Name TEXT NOT NULL, Colour TEXT NOT NULL: Te linie definiują kolejne kolumny (Type, Name, Colour), które będą przechowywać tekst (łańcuchy znaków). NOT NULL określa, że dla każdego rekordu w tabeli, wartości w tych kolumnach nie mogą być puste (NULL), co oznacza, że muszą zostać podane podczas dodawania rekordu do tabeli.
Growth INTEGER, Happiness INTEGER, Appearance INTEGER, Strength INTEGER, Satisfaction INTEGER: Definiują kolejne kolumny, które będą przechowywać liczby całkowite (INTEGER). Reprezentują one różne atrybuty lub cechy, które mogą być przypisane do obiektów (np. zwierząt) reprezentowanych przez rekordy w tabeli GameStates. Nie ma tu klauzuli NOT NULL, co oznacza, że te wartości mogą być puste w nowych rekordach, chyba że określono inaczej w logice aplikacji.
Polecenie SQL zamknięte jest w tzw. surowym łańcuchu znaków (raw string literal) w C++, co pozwala na zapisywanie wielolinijkowych łańcuchów bez konieczności używania escape'owania specjalnych znaków, jak to ma miejsce w tradycyjnych łańcuchach znaków. Literały surowe zaczynają się od R"( i kończą na )", co pozwala na czytelne i wygodne formatowanie zapytań SQL bezpiecznie zawartych w kodzie źródłowym C++.
Literały surowe (raw string literals) w C++ umożliwiają tworzenie łańcuchów znaków, które mogą zawierać sekwencje, które w tradycyjnych literałach łańcuchowych wymagałyby użycia znaków ucieczki (escape characters), takich jak nowe linie (\n), cudzysłowy (") czy backslash'e (\). Literały surowe są szczególnie przydatne, gdy chcesz zawrzeć w swoim kodzie dłuższe fragmenty tekstu z zachowaniem ich oryginalnego formatowania, na przykład zapytania SQL, fragmenty kodu HTML czy ścieżki systemowe w systemach Windows, które używają backslash'y jako separatorów.
Użycie R"( na początku i )" na końcu pozwala na umieszczenie całego zapytania SQL wewnątrz literału łańcuchowego bez konieczności escapowania cudzysłowów czy dodawania znaków nowej linii. Całe zapytanie jest traktowane jako pojedynczy ciąg znaków, co ułatwia czytanie i utrzymanie kodu, zwłaszcza przy długich i skomplikowanych zapytaniach SQL.

10. Funkcja do tworzenia tabeli w c++
    char* errMsg = nullptr;
    rc = sqlite3_exec(db, sqlCreateTable, nullptr, nullptr, &errMsg);
    if (rc != SQLITE_OK) {
        cerr << "Error creating SQLite table: " << errMsg << endl;
        sqlite3_free(errMsg);
        sqlite3_close(db);
        exit(1);
    } else {
        cout << "Table created successfully" << endl;
    }
}

Na rozmowie o pracę, ważne jest, aby dokładnie wyjaśnić każdy fragment kodu, pokazując swoje zrozumienie nie tylko na poziomie składni, ale również konceptualnym. Oto szczegółowe wyjaśnienie powyższego fragmentu:
char* errMsg = nullptr;
Wyjaśnienie: Tutaj deklarujemy wskaźnik errMsg typu char* i inicjalizujemy go wartością nullptr. Wskaźnik ten będzie używany do przechowywania wiadomości o błędzie zwróconej przez funkcję sqlite3_exec w przypadku wystąpienia błędu podczas wykonania zapytania SQL.
rc = sqlite3_exec(db, sqlCreateTable, nullptr, nullptr, &errMsg);
Wyjaśnienie: Wywołujemy funkcję sqlite3_exec, aby wykonać zapytanie SQL przechowywane w zmiennej sqlCreateTable. Pierwszy argument db to wskaźnik na obiekt bazy danych SQLite. Drugi argument to zapytanie SQL. Trzeci i czwarty argument (nullptr) to wskaźniki na funkcję zwrotną i dane użytkownika, których tutaj nie używamy. Ostatni argument to miejsce, gdzie zostanie zapisany ewentualny komunikat o błędzie. Zmienna rc przechowuje kod powrotu funkcji, który informuje nas o powodzeniu lub niepowodzeniu wykonania zapytania.
if (rc != SQLITE_OK) {
Wyjaśnienie: Sprawdzamy, czy wykonanie zapytania zakończyło się sukcesem. SQLITE_OK to stała reprezentująca pomyślne zakończenie operacji. Jeśli rc różni się od SQLITE_OK, oznacza to, że podczas wykonywania zapytania wystąpił błąd.
cerr << "Error creating SQLite table: " << errMsg << endl;
sqlite3_free(errMsg);
sqlite3_close(db);
exit(1);
Wyjaśnienie: W przypadku błędu wyświetlamy komunikat o błędzie, korzystając z cerr. Następnie zwalniamy pamięć przydzieloną na komunikat o błędzie za pomocą sqlite3_free(errMsg), zamykamy połączenie z bazą danych za pomocą sqlite3_close(db) i kończymy działanie programu z kodem błędu 1, wskazując, że wystąpił problem.
} else {
cout << "Table created successfully" << endl;
}
Wyjaśnienie: Jeśli zapytanie zakończyło się sukcesem (nie weszliśmy do bloku if), wyświetlamy komunikat o pomyślnym utworzeniu tabeli, korzystając z cout. Używając else, zapewniamy, że ten komunikat zostanie wyświetlony tylko wtedy, gdy nie wystąpił żaden błąd.
Podczas rozmowy o pracę ważne jest, aby pokazać, że rozumiesz, jak ważna jest obsługa błędów oraz że potrafisz zaimplementować klarowny i bezpieczny kod dostępu do bazy danych, który jest również przyjazny dla użytkownika dzięki odpowiednim komunikatom o stanie operacji.
sqlite3_stmt *stmt;
char *errmsg = nullptr;
int rc = sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, &errmsg);
if (rc != SQLITE_OK) {
    cerr << "Begin transaction error: " << errmsg << endl;
    sqlite3_free(errmsg);
    return;
}

11. Metoda saveGameState

void saveGameState() {
    lock_guard<mutex> lock(db_mutex);

    const char* sqlInsert = R"(
        INSERT INTO GameStates (Type, Name, Colour, Growth, Happiness, Appearance, Strength, Satisfaction)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?);
    )";

    sqlite3_stmt* stmt;
    char* errmsg = 0;
    int rc = sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, &errmsg);
    if (rc != SQLITE_OK) {
        cerr << "Begin transaction error: " << errmsg << endl;
        sqlite3_free(errmsg);
        return;
    }

    rc = sqlite3_prepare_v2(db, sqlInsert, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        cerr << "Failed to prepare statement: " << sqlite3_errmsg(db) << std::endl;
        return;
    }

    for (const auto& animal : trainedAnimals) {
        sqlite3_bind_text(stmt, 1, animal->type.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, animal->name.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 3, animal->colour.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_int(stmt, 4, animal->features["growth"]);
        sqlite3_bind_int(stmt, 5, animal->features["happiness"]);
        sqlite3_bind_int(stmt, 6, animal->features["appearance"]);
        sqlite3_bind_int(stmt, 7, animal->features["strength"]);
        sqlite3_bind_int(stmt, 8, animal->features["satisfaction"]);

        rc = sqlite3_step(stmt);
        if (rc != SQLITE_DONE) {
            cerr << "Failed to insert game state: " << sqlite3_errmsg(db) << std::endl;
            sqlite3_clear_bindings(stmt);
            sqlite3_reset(stmt);
            sqlite3_exec(db, "ROLLBACK;", NULL, NULL, &errmsg);
            cerr << "Rollback executed due to an error." << std::endl;
            sqlite3_free(errmsg);
            sqlite3_finalize(stmt);
            return;
        }

        // Resetowanie zapytania dla kolejnego użycia
        sqlite3_clear_bindings(stmt);
        sqlite3_reset(stmt);
    }

    sqlite3_finalize(stmt); // Zwolnienie zasobów zapytania

    // Zatwierdzenie transakcji
    rc = sqlite3_exec(db, "COMMIT;", NULL, NULL, &errmsg);
    if (rc != SQLITE_OK) {
        std::cerr << "Commit error: " << errmsg << std::endl;
        sqlite3_free(errmsg);
    }
}

Metoda saveGameState() w Twoim kodzie służy do zapisywania stanu gry, w tym przypadku stanu obiektów Animal, do bazy danych SQLite. Oto szczegółowy opis działania tej metody:
Lock na mutex: lock_guard<mutex> lock(db_mutex); zabezpiecza dostęp do bazy danych, aby zapewnić, że operacje na bazie danych są wykonywane atomowo i nie dochodzi do konfliktów dostępu w przypadku wielowątkowości.
Definicja zapytania SQL: Zmienna sqlInsert przechowuje szablon zapytania SQL do wstawienia danych do tabeli GameStates. Używa znaczników zastępczych (?), które zostaną zastąpione rzeczywistymi wartościami przy użyciu funkcji sqlite3_bind_*.
Rozpoczęcie transakcji: Wywołanie sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, &errmsg); rozpoczyna transakcję w bazie danych. Transakcje zapewniają, że zestaw operacji (w tym przypadku wstawianie) zostanie wykonany jako całość, co zwiększa bezpieczeństwo danych.
Przygotowanie zapytania: sqlite3_prepare_v2(db, sqlInsert, -1, &stmt, nullptr); przygotowuje zapytanie SQL do wykonania. Zwraca przygotowane zapytanie (prepared statement) w zmiennej stmt.
Pętla przez obiekty Animal: Dla każdego obiektu Animal w trainedAnimals, kod powiązuje dane obiektu z zapytaniem przy użyciu funkcji sqlite3_bind_text() i sqlite3_bind_int(), zastępując znaczniki zastępcze (?) rzeczywistymi wartościami.
Wykonanie zapytania: sqlite3_step(stmt); wykonuje przygotowane zapytanie. Jeżeli nie zakończy się sukcesem (SQLITE_DONE), wywołana zostaje transakcja rollback, cofająca wszelkie zmiany wprowadzone w ramach bieżącej transakcji, co zapobiega częściowemu zapisowi danych.
Resetowanie i czyszczenie zapytania: sqlite3_clear_bindings(stmt); i sqlite3_reset(stmt); czyści powiązania i resetuje zapytanie, aby mogło być użyte ponownie z nowymi wartościami dla kolejnego obiektu.
Finalizacja zapytania: sqlite3_finalize(stmt); zwalnia zasoby zapytania po jego wykonaniu.
Zakończenie transakcji: Na koniec, sqlite3_exec(db, "COMMIT;", NULL, NULL, &errmsg); zatwierdza transakcję. Jeśli operacja nie powiedzie się, wyświetlany jest komunikat o błędzie, a zmiany wprowadzone w ramach transakcji zostają zachowane w bazie danych.
Podsumowując, metoda saveGameState() używa transakcji, przygotowanych zapytań i odpowiedniego powiązania danych, aby bezpiecznie i efektywnie zapisywać stany obiektów Animal w bazie danych SQLite. Zapewnia to integralność danych i poprawia wydajność operacji bazodanowych.

Ad. mutex (dokladne wyjaśnienie) 
std::lock_guard<std::mutex> lock(db_mutex); to linijka kodu używająca mechanizmu RAII (Resource Acquisition Is Initialization) do automatycznego zarządzania blokadą na mutexie w C++. Kiedy obiekt lock typu std::lock_guard<std::mutex> jest tworzony, przejmuje on własność nad mutexem db_mutex poprzez jego zablokowanie. Dzięki temu mechanizmowi, mutex jest automatycznie odblokowywany, gdy obiekt lock zostanie zniszczony, czyli na końcu bloku kodu, w którym został zadeklarowany. Jest to szczególnie przydatne w przypadku, gdy w funkcji występuje wiele punktów wyjścia lub gdy może zostać rzucony wyjątek, ponieważ zapewnia to, że zasoby będą zawsze poprawnie zwolnione, niezależnie od tego, jak funkcja zostanie zakończona.
W kontekście Twojego kodu, lock_guard jest używany do synchronizacji dostępu do bazy danych SQLite, zapobiegając jednoczesnemu dostępowi z różnych wątków, co mogłoby prowadzić do wyścigów i nieprzewidywalnych błędów. Kiedy wywoływana jest funkcja saveGameState(), pierwsze co się dzieje, to zablokowanie mutex, co zapewnia, że tylko jeden wątek na raz może wykonywać kod wewnątrz tej funkcji. To kluczowe dla zachowania spójności danych w aplikacji wielowątkowej.
Syntaktycznie, std::lock_guard jest szablonem klasy w bibliotece standardowej C++, który wymaga określenia typu mutexu, z którym ma współpracować, jako parametru szablonu. W Twoim przypadku jest to std::mutex, co oznacza, że lock_guard będzie zarządzał blokadą na obiekcie typu std::mutex.
Ogólna forma deklaracji lock_guard wygląda tak:
std::lock_guard<typ_mutexu> nazwa_obiektu(mutex);
Gdzie:
typ_mutexu to typ mutexu, którym zarządza lock_guard. W przypadku standardowego mutexu z biblioteki C++ będzie to std::mutex.
nazwa_obiektu to nazwa, którą nadajesz instancji lock_guard.
mutex to obiekt mutexu, który lock_guard ma zablokować przy tworzeniu i automatycznie odblokować przy zniszczeniu instancji lock_guard.
W Twoim kodzie:
std::lock_guard<std::mutex> lock(db_mutex);
std::mutex wskazuje, że lock_guard będzie zarządzał standardowym mutexem.
lock jest nazwą obiektu lock_guard. Możesz użyć dowolnej nazwy, która jest zgodna z zasadami nazewnictwa w C++, ale dobrą praktyką jest używanie nazw, które jasno określają zastosowanie lub kontekst użytego zasobu.
db_mutex to obiekt std::mutex, który jest zablokowany przez lock_guard. Kiedy obiekt lock jest tworzony, db_mutex jest automatycznie zablokowany, a kiedy zakres życia lock dobiegnie końca (czyli na końcu bloku kodu, w którym lock został zadeklarowany), db_mutex jest automatycznie odblokowywany.
To podejście eliminuje potrzebę ręcznego zarządzania blokadą mutexu i gwarantuje, że blokada zostanie zwolniona nawet w przypadku wystąpienia wyjątku, co zwiększa bezpieczeństwo i niezawodność kodu.


12. Metoda loadGameState
void loadGameState() {
    db_mutex.lock();
    const char* sqlSelect = "SELECT Type, Name, Colour, Growth, Happiness, Appearance, Strength, Satisfaction FROM GameStates";
    sqlite3_stmt* stmt;

    if (sqlite3_prepare_v2(db, sqlSelect, -1, &stmt, nullptr) == SQLITE_OK) {
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            string type = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
            string name = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
            string colour = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
            int growth = sqlite3_column_int(stmt, 3);
            int happiness = sqlite3_column_int(stmt, 4);
            int appearance = sqlite3_column_int(stmt, 5);
            int strength = sqlite3_column_int(stmt, 6);
            int satisfaction = sqlite3_column_int(stmt, 7);

           
            auto animal = make_shared<Animal>(type, name, colour, growth, happiness, appearance, strength, satisfaction);
            trainedAnimals.push_back(animal);
        }
        sqlite3_finalize(stmt);
    } else {
        cerr << "Failed to prepare select statement: " << sqlite3_errmsg(db) << endl;
    }

    db_mutex.unlock();
}


SELECT: To kluczowe słowo SQL, które służy do wybierania danych z bazy danych. Za pomocą SELECT określasz, które kolumny chcesz pobrać z określonej tabeli.Lista kolumn: Type, Name, Colour, Growth, Happiness, Appearance, Strength, Satisfaction - to są nazwy kolumn, które chcesz pobrać z tabeli. W tym przypadku zapytanie prosi o pobranie wartości z wszystkich kolumn dostępnych dla tabeli GameStates, co pozwoli na pełne odtworzenie stanu każdego obiektu Animal przechowywanego w bazie danych.
FROM GameStates: Określa tabelę, z której mają być pobrane dane, czyli GameStates. To oznacza, że zapytanie będzie operować na danych zawartych właśnie w tej tabeli.
sqlite3_stmt* stmt;: Ta linijka nie jest częścią zapytania SQL, ale deklaracją wskaźnika na strukturę sqlite3_stmt, która w SQLite reprezentuje przygotowane zapytanie (prepared statement). W kontekście tego zapytania, stmt będzie użyty do przechowywania skompilowanego zapytania SQL po wywołaniu funkcji sqlite3_prepare_v2(), co umożliwi jego późniejsze wykonanie i iterację po wynikach.
sqlite3_prepare_v2(db, sqlSelect, -1, &stmt, nullptr): Funkcja przygotowuje zapytanie SQL do wykonania, przekształcając zapytanie tekstowe sqlSelect na skompilowaną formę, którą można wykonać za pomocą SQLite. Pierwszy argument (db) to wskaźnik na obiekt bazy danych SQLite. Drugi argument to zapytanie SQL, które chcesz przygotować. Trzeci argument określa długość zapytania SQL; -1 oznacza, że SQLite powinno samodzielnie określić długość zapytania na podstawie znaku null na końcu. Czwarty argument (&stmt) to miejsce, gdzie zostanie zapisany wskaźnik na przygotowane zapytanie. Ostatni argument to wskaźnik na wskaźnik na żadne (nullptr), który jest używany w zaawansowanych scenariuszach (tutaj nie jest używany).
while (sqlite3_step(stmt) == SQLITE_ROW): Funkcja sqlite3_step wykonuje przygotowane zapytanie i przechodzi do kolejnego rekordu w wynikach zapytania. Pętla while kontynuuje iterację, dopóki sqlite3_step zwraca SQLITE_ROW, co oznacza, że istnieje kolejny wiersz danych do przetworzenia.
SQLITE_ROW to stała zdefiniowana w bibliotece SQLite, która wskazuje, że kolejny wiersz danych jest dostępny do odczytu. Jest ona zwracana przez funkcję sqlite3_step() podczas iterowania przez wyniki zapytania SQL.
Gdy wykonujesz zapytanie przy użyciu sqlite3_step(), istnieje kilka możliwych wyników (kodów wyników), które ta funkcja może zwrócić. Jednym z nich jest SQLITE_ROW, który oznacza, że funkcja sqlite3_step() pomyślnie przeszła do następnego wiersza zestawu wyników. To oznacza, że można odczytać dane z tego wiersza, korzystając z funkcji takich jak sqlite3_column_text(), sqlite3_column_int(), sqlite3_column_double() itp., aby uzyskać wartości z poszczególnych kolumn tego wiersza.
string type = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)); Ta linia kodu odczytuje tekstową wartość z pierwszej kolumny bieżącego wiersza wyniku zapytania SQLite i przypisuje ją do zmiennej type typu string w języku C++. Oto szczegółowy opis składni i działania tej linii:
sqlite3_column_text(stmt, 0): sqlite3_column_text jest funkcją biblioteki SQLite, która zwraca wartość tekstową kolumny z bieżącego wiersza wyniku zapytania.
Pierwszy argument, stmt, to wskaźnik na przygotowane zapytanie (sqlite3_stmt*), który zawiera wyniki zapytania.
Drugi argument to indeks kolumny, z której ma być pobrana wartość. W SQLite kolumny są numerowane od 0, więc 0 oznacza pierwszą kolumnę wyniku zapytania.
reinterpret_cast<const char*>:
reinterpret_cast to operator rzutowania w C++, który pozwala na konwersję jednego wskaźnika na inny, zmieniając jego typ bez zmiany reprezentacji bitowej. Jest to rodzaj rzutowania "na surowo", który nie wykonuje żadnej dodatkowej logiki konwersji i jest używany, gdy inne rodzaje rzutowania są niewystarczające.
W tym przypadku reinterpret_cast<const char*> zmienia typ zwracany przez sqlite3_column_text, który jest const unsigned char*, na const char*. Jest to potrzebne, ponieważ konstruktor string w C++ oczekuje const char* jako argumentu, gdy tworzy string na podstawie ciągu znaków C-style.
string type = ...:
Tworzy nową zmienną type typu string (ciąg znaków w C++), która jest inicjalizowana wartością tekstową przekształconą z const unsigned char* na const char*.
Użycie string przed type deklaruje zmienną o nazwie type i typie string, czyli typie dostępnym w standardowej bibliotece języka C++ służącym do reprezentacji i pracy z tekstami.
Podsumowując, cała operacja pobiera tekst z pierwszej kolumny wyniku zapytania SQL, konwertuje go z const unsigned char* na const char* za pomocą reinterpret_cast, a następnie tworzy z niego obiekt string, który jest przypisany do zmiennej type.
int happiness = sqlite3_column_int(stmt, 4);Ta linia kodu odczytuje wartość całkowitą (typu int) z czwartej kolumny bieżącego wiersza wyniku zapytania SQLite i przypisuje ją do zmiennej growth typu int w języku C++. Oto dokładny opis działania tej linii:
sqlite3_column_int(stmt, 3):
sqlite3_column_int jest funkcją biblioteki SQLite, która zwraca wartość całkowitą kolumny z bieżącego wiersza wyniku zapytania.
stmt to wskaźnik na przygotowane zapytanie (sqlite3_stmt*), zawierający wyniki zapytania.
Drugi argument, 3, oznacza indeks kolumny, z której ma być pobrana wartość. W SQLite kolumny są numerowane od 0, więc 3 oznacza czwartą kolumnę wyniku zapytania.
int growth = ...:
Deklaruje nową zmienną growth typu int i inicjalizuje ją wartością całkowitą pobraną z czwartej kolumny wyniku zapytania.
Podsumowując, operacja ta pobiera wartość całkowitą z czwartej kolumny bieżącego wiersza wyniku zapytania i przypisuje ją do zmiennej lokalnej growth. Użycie tej funkcji jest powszechną praktyką, gdy chcesz pracować z wartościami liczbowymi przechowywanymi w bazie danych SQLite.



if (getUserConfirmation("\033[1mDo you want to develop a new pet?\033[0m")) {
                    animal = Animal ("", "", "", 0, 0, 0, 0, 0);
                    welcome();
                    animal = createAnimal();
                    continue;
                } else {
                    cout << "\033[1m\033[35mThank you, that's it for today.\033[0m" << endl;
                    exit(0);
                }
            }


Oto wyjaśnienie poszczególnych linii kodu:

if (getUserConfirmation("\033[1mDo you want to develop a new pet?\033[0m")) {: Warunek if sprawdza, czy użytkownik potwierdził chęć utworzenia nowego zwierzaka, korzystając z funkcji getUserConfirmation, która wyświetla pytanie w pogrubionym stylu. Jeśli użytkownik potwierdzi chęć, warunek ten zwróci true, w przeciwnym razie zwróci false.
animal = Animal ("", "", "", 0, 0, 0, 0, 0);: Tutaj tworzony jest obiekt Animal o pustych polach, który zostanie później zaktualizowany przez użytkownika.
welcome();: Wywołanie funkcji welcome(), która prawdopodobnie wyświetla powitanie użytkownika lub inne informacje na ekranie.
animal = createAnimal();: Wywołanie funkcji createAnimal(), która umożliwia użytkownikowi wprowadzenie danych nowego zwierzaka. Te dane są przypisywane do obiektu animal.
continue;: Instrukcja continue powoduje przejście do kolejnej iteracji pętli, w tym przypadku do następnej iteracji pętli while, która otacza ten blok kodu.
} else {: Ta część kodu wykonuje się, jeśli warunek if z linii 1 zwrócił false, co oznacza, że użytkownik nie wyraził zgody na utworzenie nowego zwierzaka.
cout << "\033[1m\033[35mThank you, that's it for today.\033[0m" << endl;: Wyświetlenie komunikatu podziękowania za dzisiejszą interakcję.
exit(0);: Wywołanie funkcji exit z argumentem 0 powoduje natychmiastowe zakończenie programu. Jeśli użytkownik nie chce rozwijać nowego zwierzaka, program kończy się po wyświetleniu komunikatu podziękowania.
        
        