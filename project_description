1. #include <iostream>
    // Dyrektywa #include <iostream> w języku C++ jest instrukcją preprocesora, która wskazuje kompilatorowi, aby dołączył standardową bibliotekę wejścia-wyjścia przed rozpoczęciem kompilacji programu. Biblioteka ta zawiera definicje klas i funkcji służących do operacji wejścia i wyjścia, takich jak czytanie danych z klawiatury i wypisywanie danych na ekran.
2. #include <string> 
    // Dyrektywa #include <string> w języku C++ wskazuje kompilatorowi, aby dołączył standardową bibliotekę string przed rozpoczęciem procesu kompilacji. Biblioteka ta zawiera definicję klasy std::string, która jest używana do reprezentowania i manipulowania ciągami znaków w C++.
3. #include <unordered_map>
    // Dyrektywa #include <unordered_map> w języku C++ informuje kompilator o konieczności dołączenia standardowej biblioteki, która zawiera definicję kontenera std::unordered_map. Kontener ten jest częścią Standardowej Biblioteki Szablonów (STL) i służy do przechowywania par klucz-wartość w sposób nieuporządkowany.
4. #include <vector>
    // W C++, dyrektywa #include <vector> służy do dołączenia nagłówka biblioteki standardowej, która zawiera definicję klasy szablonowej std::vector. std::vector jest jednym z kontenerów sekwencyjnych dostępnych w Standardowej Bibliotece Szablonów (STL) i służy do przechowywania i zarządzania kolekcjami elementów.
    // Główne cechy std::vector:

    // Dynamiczna tablica: std::vector automatycznie zarządza swoją pamięcią i potrafi zmieniać swój rozmiar w czasie wykonania programu, dodając nowe elementy lub usuwając istniejące. Jest to bardziej elastyczne niż statycznie alokowane tablice.

    // Sekwencyjny dostęp do elementów: Elementy w wektorze są przechowywane sekwencyjnie w pamięci, co oznacza, że dostęp do nich jest szybki i efektywny. Można bezpośrednio odwołać się do każdego elementu wektora za pomocą indeksu.

    // Automatyczne zarządzanie pamięcią: std::vector automatycznie alokuje i dealokuje pamięć, kiedy jest to potrzebne, dzięki czemu programista nie musi się martwić o ręczne zarządzanie pamięcią.

    // Elastyczność: std::vector oferuje wiele funkcji do manipulowania zawartością wektora, takich jak push_back(), pop_back(), insert(), erase(), clear() i wiele innych.
5. #include <algorithm>
    //Dyrektywa #include <algorithm> w języku C++ służy do dołączenia nagłówka biblioteki standardowej, która zawiera szereg funkcji algorytmicznych ogólnego przeznaczenia. Biblioteka <algorithm> jest jedną z najbardziej użytecznych i wszechstronnych części Standardowej Biblioteki Szablonów (STL) i oferuje szeroki zakres funkcji do operacji na kontenerach i zakresach danych. Funkcje te obejmują operacje takie jak sortowanie, wyszukiwanie, manipulowanie sekwencjami danych, operacje na zbiorach, oraz inne algorytmy użyteczne w programowaniu.
6. #include <cctype> 
    //Biblioteka <cctype> w języku C++ jest częścią standardowej biblioteki języka i dostarcza zestaw funkcji do sprawdzania i manipulowania znakami. Te funkcje są użyteczne, gdy pracujesz z tekstami, np. przy przetwarzaniu lub analizowaniu ciągów znaków.
    //W przypadku mojego programu biblioteka została użyta w celu zastosowania funkcj tolower(int c) która konwertuje dany znak na małą literę, jeśli jest to możliwe.
7. #include <memory>
    //służy do dołączania nagłówka <memory> z biblioteki standardowej C++. Nagłówek ten zawiera definicje klas i funkcji służących do zarządzania pamięcią w sposób bezpieczny i efektywny, szczególnie przy użyciu inteligentnych wskaźników. 
8. using namespace std;
    //Dyrektywa using namespace std; w języku C++ jest wykorzystywana do informowania kompilatora, że chcemy używać wszystkich elementów (takich jak funkcje, klasy, zmienne) znajdujących się w przestrzeni nazw (namespace) o nazwie std bez konieczności ich jawnego prefiksowania. Przestrzeń nazw std jest standardową przestrzenią nazw w C++, w której zdefiniowane są wszystkie biblioteki standardowe, takie jak kontenery STL, operacje wejścia/wyjścia, algorytmy, itd.
9. string toLower(const string& str) {
    string lowerStr;
    lowerStr.reserve(str.size()); // Rezerwuje miejsce w pamięci dla nowego stringa, by był równy rozmiarowi wejściowego stringa
    for (char c : str) { // Iteruje przez każdy znak w wejściowym stringu
        lowerStr += tolower(c); // Konwertuje każdy znak na małą literę i dodaje do nowego stringa
    }
    return lowerStr; // Zwraca przekonwertowany string
}    

    //Kluczowe elementy funkcji toLower:
    //Parametr funkcji: const string& str oznacza, że funkcja przyjmuje referencję do stringa jako parametr. Użycie const gwarantuje, że oryginalny string przekazany do funkcji nie zostanie zmodyfikowany przez tę funkcję, co jest dobrą praktyką, gdy nie potrzebujemy modyfikować wejściowego argumentu. 
    //W celu zrozumienia parapetrów przekazywanych przez referencje (po mojemu): Gdyby argument był przekazany przez wartość, to w kolejnych linijkach kodu użycie 'str' powodowałoby kopiowania oryginalnego obiektu za każdym razem. W przypadku przekazania argumentu przez referencje unikamy kopiowania, ponieważ funkcja operuje bezpośrednio na oryginalnym obiekcie, co znacznie poprawia wydajność programu. W przypadku tej funkcji toLowe użycie wartości zamiast referencji jako parametru funkcji nie zmieniłoby funkcjonalności, natomiast znacząco wpłynęło by na wydajność programu.
    //Rezerwacja miejsca w pamięci: lowerStr.reserve(str.size()); jest optymalizacją, która alokuje odpowiednią ilość pamięci dla stringa lowerStr z góry, bazując na rozmiarze wejściowego stringa str. Dzięki temu unikamy niepotrzebnych realokacji pamięci podczas dodawania nowych znaków do lowerStr.
    //Iteracja po każdym znaku: Pętla for (char c : str) przechodzi przez każdy znak w stringu str, umożliwiając jego przetworzenie.
    //Konwersja na małe litery: tolower(c) jest standardową funkcją z biblioteki <cctype>, która konwertuje dany znak c na małą literę, jeśli jest to litera. Jeśli c jest już małą literą lub nie jest literą, funkcja zwraca c bez zmian.
    //Składanie wynikowego stringa: lowerStr += tolower(c); dodaje przekonwertowany znak do końca stringa lowerStr, budując wynikowy string znak po znaku.
    //Zwrócenie wyniku: return lowerStr; kończy działanie funkcji, zwracając wynikowy string, który zawiera wszystkie znaki z wejściowego stringa str, ale przekonwertowane na małe litery.
    //Dzięki tej funkcji, możesz łatwo przekształcić dowolny string na wersję składającą się wyłącznie z małych liter, co jest szczególnie użyteczne przy porównywaniu stringów w sposób niezależny od wielkości liter.

10.  bool getUserConfirmation(const string &question) {
    string response;
    while(true) {
        cout << question << (" \033[1m(yes/no)\033[0m");
        cin >> response;
        string lowerResponse = toLower(response);

        if (lowerResponse == "yes") {
            return true;
        } else if (lowerResponse == "no"){
            return false;
        } else {
            cout << "\033[1m\033[31mPlease enter 'yes' or 'no'.\033[0m" << endl;
        }
    }
}

    //Ta funkcja zadaje użytkownikowi pytanie i oczekuje na odpowiedź "yes" lub "no". Jeśli odpowiedź jest inna, użytkownik jest ponownie proszony o wprowadzenie jednej z akceptowalnych odpowiedzi. Funkcja zwraca true, gdy odpowiedź to "yes", i false, gdy odpowiedź to "no".
    //Poniżej wyjaśnieje każdej linijki kodu:
    //bool getUserConfirmation(const string& question) { - Ta linijka rozpoczyna definicję funkcji getUserConfirmation, która przyjmuje jeden argument typu string - question. Funkcja zwraca wartość typu bool, która wskazuje, czy użytkownik potwierdził akcję (true) czy ją odrzucił (false).
    // string response - Deklaracja zmiennej response typu string, która będzie przechowywać odpowiedź użytkownika wprowadzoną z klawiatury.
    //while (true) { - Rozpoczęcie nieskończonej pętli while, która będzie działać do momentu otrzymania poprawnej odpowiedzi od użytkownika ("yes" lub "no").
    //cout << question << " (yes/no): " - Wyświetlenie pytania przekazanego do funkcji, z dodanym wyjaśnieniem, że oczekiwane są odpowiedzi "yes" lub "no".
    //cin >> response - Pobranie odpowiedzi od użytkownika i zapisanie jej w zmiennej response.
    // string lowerResponse = toLower(response) - Konwersja odpowiedzi użytkownika na małe litery za pomocą wcześniej zdefiniowanej funkcji toLower i zapisanie wyniku do nowej zmiennej lowerResponse. Umożliwia to porównanie bez uwzględnienia wielkości liter.
    //if (lowerResponse == "yes") {
            return true - Sprawdzenie, czy przekonwertowana odpowiedź to "yes". Jeśli tak, funkcja zwraca true, co oznacza potwierdzenie przez użytkownika.
    // } else if (lowerResponse == "no") {
            return false - Sprawdzenie, czy przekonwertowana odpowiedź to "no". Jeśli tak, funkcja zwraca false, co oznacza odrzucenie przez użytkownika. 
    //} else {
            cout << "Please enter 'yes' or 'no'." << endl -   Jeśli odpowiedź nie jest ani "yes", ani "no" (po konwersji na małe litery), użytkownik jest informowany o błędzie i proszony o ponowne wprowadzenie odpowiedzi. Funkcja nie zwraca wartości w tym miejscu, co oznacza kontynuację pętli.

11. public:, protected: i private: są specyfikatorami dostępu (ang. access specifiers). Służą one do określenia poziomu dostępu do członków klasy (pól, metod i innych członków klasy) w programowaniu obiektowym. Oto krótkie wyjaśnienie każdego z nich:
    // public: Specyfikator dostępu public oznacza, że dany członek klasy jest dostępny zarówno z wnętrza klasy, jak i z zewnątrz. Oznacza to, że metody, pola czy inne elementy oznaczone jako publiczne mogą być swobodnie używane przez inne klasy.
    //protected: Specyfikator dostępu protected oznacza, że dany członek klasy jest dostępny z wnętrza klasy oraz w klasach pochodnych (dziedziczących), ale nie jest dostępny bezpośrednio z obiektów klasy. Członkowie chronieni protected są więc dostępni dla klas potomnych, co umożliwia większą kontrolę nad dziedziczeniem i dostępem.
    //private:Specyfikator dostępu private oznacza, że dostęp do danego członka klasy jest ograniczony wyłącznie do wnętrza klasy, w której został zdefiniowany. Inne klasy, nawet te dziedziczące po klasie z prywatnymi członkami, nie mają do nich dostępu. Jest to domyślny poziom dostępu dla członków klasy w C++.

12. Animal(string type, string name, string colour) : type(type), name(name), colour(colour) {
    features = {{"growth", 0}, {"happiness", 0}, {"appearance", 0}, {"strength", 0}, {"satisfaction", 0}};
}
    // Konstruktor w klasi Animal. Jego głownym celem jest przgotowanie obiektu Animal do użycia poprzez ustawienie jego stamu początkowego czyli przypisanie wartości do atrybutów (type, name, colour) oraz inicjalizację mapy features z początkowymi cechami zwierzęcia. 
    //Animal(parametry konstruktora z trzema argumentami odpowiadającymi atrybutom klasy) : (lista inicjalizacyjna do bezpośredniego przypisania wartości przekazanych jako argumenty do odpowiednich atrybutów.) {
    ciało konstruktora w którym inicjalizowana jest mapa przechowująca cechy zwierzęcia i jego wartości początkowe
}


13. void performAction(const string& action) {
    // Sprawdza, jaka akcja została podana jako argument.
    if (action == "eat") {
        // Jeśli akcja to "eat", zwiększa wartość cechy "growth" o 1.
        features["growth"] += 1;
        // Wypisuje informację o wykonanej akcji oraz aktualnej wartości cechy "growth".
        cout << "Performed: " << action << ". " << name << " now has " << features["growth"] << " growth." << endl;
    } else if (action == "play") {
        // Jeśli akcja to "play", zwiększa wartość cechy "happiness" o 1.
        features["happiness"] += 1;
        // Wypisuje informację o wykonanej akcji oraz aktualnej wartości cechy "happiness".
        cout << "Performed: " << action << ". " << name << " now has " << features["happiness"] << " happiness." << endl;
    } else if (action == "wash") {
        // Jeśli akcja to "wash", zwiększa wartość cechy "appearance" o 1.
        // Uwaga: w poprzednich przykładach używaliśmy "cleanliness", a nie "appearance".
        features["appearance"] += 1;
        // Wypisuje informację o wykonanej akcji oraz aktualnej wartości cechy "appearance".
        cout << "Performed: " << action << ". " << name << " now has " << features["appearance"] << " appearance." << endl;
    } else if (action == "sleep") {
        // Jeśli akcja to "sleep", zwiększa wartość cechy "strength" o 1.
        features["strength"] += 1;
        // Wypisuje informację o wykonanej akcji oraz aktualnej wartości cechy "strength".
        cout << "Performed: " << action << ". " << name << " now has " << features["strength"] << " strength." << endl;
    } else if (action == "stroke") {
        // Jeśli akcja to "stroke", zwiększa wartość cechy "satisfaction" o 1.
        features["satisfaction"] += 1;
        // Wypisuje informację o wykonanej akcji oraz aktualnej wartości cechy "satisfaction".
        cout << "Performed: " << action << ". " << name << " now has " << features["satisfaction"] << " satisfaction." << endl;
    } else {
        // Jeśli podana akcja nie pasuje do żadnej z powyższych, informuje o tym użytkownika.
        cout << "Unknown action: " << action << ". No changes made." << endl;
    }   
}

    //Użycie referencji (const string& action) pozwala na efektywniejsze przekazywanie ciągów znaków do funkcji, ponieważ unika się kopiowania wartości, co jest korzystne zwłaszcza przy dużych ciągach znaków. const zapewnia, że przekazany ciąg znaków nie zostanie zmodyfikowany wewnątrz funkcji.

14. void displayFeatures() {
        cout << name << " is a " << colour << " " << type << " with the following features: " << endl;
        for (const auto& feature : features) {
            cout << feature.first << ": " << feature.second << endl;
        }
    }

    //Pętla for z użyciem const auto& feature : features jest przykładem tzw. zakresowej pętli for (ang. range-based for loop), która została wprowadzona w standardzie C++11. Służy ona do iteracji przez wszystkie elementy kolekcji (w tym przypadku przez mapę features). Oto szczegółowe wyjaśnienie, jak jest tworzona i jak działa:
    //const auto& feature: Ten fragment deklaruje zmienną feature, która w każdej iteracji pętli przechowuje referencję do bieżącego elementu z kolekcji features. Użycie const oznacza, że nie będziemy modyfikować elementów kolekcji w ciele pętli, a auto pozwala kompilatorowi automatycznie wywnioskować właściwy typ elementu kolekcji. Ponieważ features jest mapą, każdy jej element (feature) jest parą (ang. pair), gdzie first to klucz, a second to wartość. Użycie referencji (&) zapewnia, że nie dokonujemy niepotrzebnego kopiowania elementów podczas iteracji.
    // : features: Określa kolekcję, przez którą iterujemy. W tym przypadku jest to mapa std::unordered_map<std::string, int> przechowująca cechy zwierzęcia jako pary klucz-wartość, gdzie klucz to nazwa cechy (np. "growth"), a wartość to liczba całkowita reprezentująca poziom tej cechy.
    //Ciało pętli: W każdej iteracji pętli wykonuje się blok kodu w nawiasach klamrowych {}. Tutaj wypisujemy na standardowe wyjście (konsolę) klucz i wartość bieżącego elementu mapy features, używając feature.first do dostępu do klucza i feature.second do dostępu do wartości.

15. bool hasReachedAdulthood() const {
        for (const auto& feature : features) {
            if (feature.second < 5) {
                return false;
            }
        } 
        return true;
    }

    //Metoda w klasie Animal sprawdzająca czy wszystkie cechy zostały ulepszone co najmniej 5 razy, wtedy zwierzę osiąga dorodłość
    //Dodanie const na końcu deklaracji metody klasy w C++ jest praktyką, która zwiększa bezpieczeństwo kodu, ograniczając możliwość nieintencjonalnej modyfikacji stanu obiektu. Jest to również wyrazem intencji programisty, że dana metoda ma być operacją tylko do odczytu bez wpływu na stan obiektu.
    //Jeśli jakakolwiek cecha ma mniej niż 5 punktów, zwierzę nie jest jeszcze dorosłe (zwraca false), natomiast zwraca true gdy wszystkie cechy mają co najmniej 5 punktów

16.  //Konstruktor inicjalizujący opisy zwierząt i możliwe akcje
  AnimalSimulator() {
        animalDescriptions = {
            {"mammals", "Mammals are a diverse group of animals that share several key traits, such as hair or fur covering the body, the ability to give birth to live young and feed them with their mother's milk. Their advanced nervous systems allow for complex social behavior."},
            {"reptiles", "Reptiles are cold-blooded animals with hard scales that inhabit a variety of environments around the world. They include snakes, lizards, crocodiles and turtles."},
            {"amphibians", "Amphibians are a unique group of cold-blooded animals that undergo metamorphosis from an aquatic larva with gills to an adult usually breathing atmospheric air. They are sensitive to changes in the environment, making them important indicators of ecosystem health."},
            {"birds", "Birds are warm-blooded animals characterized by the presence of feathers, a beak without teeth, and folding wings that in most cases allow flight"},
            {"fish", "Fish are cold-blooded aquatic animals that have fins and breathe with gills. They inhabit a variety of aquatic environments, from freshwater to salty oceans."},
            {"arthropods", "Arthropods are the most numerous group of animals on Earth, including insects, spiders, crustaceans and others. They are characterized by a segmented body, an external skeleton and paired, differentiated limbs"}
        };
        actions = {"eat", "play", "wash", "sleep", "stroke"};
    }

    //Konstruktor w klasie AnimalSimulator jest konstruktorem domyślnym, co oznacza, że nie wymaga żadnych argumentów podczas tworzenia obiektu AnimalSimulator. Jego głównym celem jest zainicjalizowanie obiektu klasy AnimalSimulator poprzez ustawienie początkowych wartości dla atrybutów klasy. 
    //Działanie konstruktora - Po utworzeniu obiektu AnimalSimulator, konstruktor automatycznie wykonuje się, inicjalizując mapę animalDescriptions i wektor actions zdefiniowanymi wartościami. Oznacza to, że każdy nowo utworzony obiekt klasy AnimalSimulator będzie miał już z góry zdefiniowane możliwe typy zwierząt i akcje, z których można korzystać w symulatorze. Inicjalizacja atrybutów w konstruktorze zapewnia, że obiekt klasy jest gotowy do użycia zaraz po jego utworzeniu, z kompletem danych niezbędnych do działania symulatora.

17. vector<shared_ptr<Animal>> trainedAnimals;
    //oznacza deklaracje kontenera typu vektor, który będzie przechowywał elementy typu shared_ptr<Animal>. Każdy element wektora jest inteligentnym wskaźnikiem wskazującym na obiekt Animal. TrainedAnimals to nazwa zmiennej dla deklarowanego wektora.
    //Podsumowując, vector<shared_ptr<Animal>> trainedAnimals deklaruje zmienną trainedAnimals jako wektor inteligentnych wskaźników na obiekty Animal. Umożliwia to bezpieczne i efektywne zarządzanie dynamiczną listą obiektów Animal, które mogą być współdzielone i zarządzane przez różne części programu.


18. Animal createAnimal() {
        string type, name, colour;
        cout << "Please select the type of animal from the list below and enter it or 'exit' to quit:" << endl;
        for (const auto& pair : animalDescriptions) {
            cout << pair.first << endl;
        }
        cin >> type;
        string lowerType = toLower(type);
        if (toLower(type) == "exit") {
            exit(0);
        }
        auto description = animalDescriptions.find(lowerType);
        if (description != animalDescriptions.end()) {
            cout << "Good choice! " << description->second << endl;
        } else {
            cout << "There is no such type of animal. Please try again." << endl;
            return createAnimal();
        }
        cout << "Now you can enter its name: ";
        cin >> name;
        cout << "Colour: ";
        cin >> colour;
        return Animal(lowerType, name, colour);
    }
        //Animal jest typem zwracanym przez metodę createAnimal(). Oznacza to, że wykonanie tej metody skutkuje utworzeniem i zwróceniem obiektu typu Animal. Metoda ta tworzy nowy obiekt Animal na podstawie danych wejściowych, które mogą być pobrane od użytkownika lub zdefiniowane w inny sposób wewnątrz metody, i następnie zwraca ten obiekt.
        //używanie instrukcji return w metodzie createAnimal() jest niezbędne, jeśli ta metoda ma zwracać obiekt typu Animal. Deklaracja metody z typem zwracanym Animal wskazuje, że po jej wykonaniu zostanie zwrócony obiekt tego typu. Aby to osiągnąć, w ciele metody musisz utworzyć obiekt typu Animal i użyć słowa kluczowego return do zwrócenia tego obiektu. Instrukcja return jest mechanizmem, za pomocą którego metoda przekazuje ten obiekt z powrotem do miejsca, z którego została wywołana.
        //Metoda  find i end mapy unordered_map w C++, jest użyta aby wyszukać i sprawdzić, czy dany typ zwierzęcia istnieje w słowniku animalDescriptions.find: Metoda find jest używana do wyszukania elementu w mapie na podstawie jego klucza. W tym przypadku type jest kluczem, który jest szukanym typem zwierzęcia. Metoda find zwraca iterator do elementu mapy, jeśli element o danym kluczu został znaleziony. Jeśli elementu o takim kluczu nie ma w mapie, find zwraca iterator równy iteratorowi zwróconemu przez metodę end mapy.
        //Funkcja toLower jest wywoływana z argumentem type, który jest stringiem wprowadzonym przez użytkownika. Argument ten reprezentuje typ zwierzęcia, który użytkownik chciał wybrać. Może być wpisany z użyciem dowolnych wielkości liter (np. "Birds", "birds", "BIRDS").Wynik działania funkcji toLower, czyli string type przekonwertowany na małe litery, jest przypisywany do nowo zadeklarowanej zmiennej lowerType. Zmienna ta teraz zawiera tę samą wartość co type, ale zapisaną wyłącznie małymi literami.
        //Poniżej kod z wyjaśnieniem każdej linijki:

        // Deklaracja funkcji `createAnimal` zwracającej obiekt klasy `Animal`
        Animal createAnimal() {
        // Deklaracja zmiennych przechowujących dane wprowadzone przez użytkownika
        string type, name, colour;
    
        // Wyświetlenie komunikatu proszącego użytkownika o wybór typu zwierzęcia z listy
        cout << "Please select the type of animal from the list below and enter it or 'exit' to quit:" << endl;
    
        // Iteracja przez mapę `animalDescriptions` zawierającą opisy typów zwierząt
        for (const auto& pair : animalDescriptions) {
        // Wyświetlenie każdego klucza z mapy, który reprezentuje typ zwierzęcia
        cout << pair.first << endl;
        }
    
        // Odczytanie typu zwierzęcia wprowadzonego przez użytkownika
        cin >> type;
    
        // Konwersja wprowadzonego typu na małe litery, aby zapewnić niezależność od wielkości liter przy porównaniu
        string lowerType = toLower(type);
    
        // Sprawdzenie, czy użytkownik wpisał 'exit', jeśli tak, program kończy działanie
        if (toLower(type) == "exit") {
        exit(0);
        }
    
        // Wyszukanie w mapie `animalDescriptions` opisu zwierzęcia odpowiadającego wprowadzonemu typowi
        auto description = animalDescriptions.find(lowerType);
    
        // Jeśli znaleziono opis, wyświetlenie potwierdzenia wyboru
        if (description != animalDescriptions.end()) {
        cout << "Good choice! " << description->second << endl;
        } else {
        // Jeśli nie znaleziono opisu, informacja o błędzie i rekurencyjne wywołanie funkcji `createAnimal`
        cout << "There is no such type of animal. Please try again." << endl;
        return createAnimal();
        }
    
        // Prośba o wprowadzenie nazwy zwierzęcia
        cout << "Now you can enter its name: ";
        cin >> name;
    
        // Prośba o wprowadzenie koloru zwierzęcia
        cout << "Colour: ";
        cin >> colour;
    
        // Utworzenie i zwrócenie obiektu `Animal` z wprowadzonymi danymi
        return Animal(lowerType, name, colour);
        }


19.   void simulate(Animal& animal) {
        string action;
    
        do {
            cout << "\033[4mPlease select the action you want to perform from the list below:\033[0m" << endl;
            for (const auto& act : actions) {
                cout << act << endl;
            }
            cin >> action;
            string lowerAction = toLower(action);
            animal.performAction(lowerAction);
            animal.displayFeatures();

            if (animal.hasReachedAdulthood()) {
                trainedAnimals.push_back(make_shared<Animal>(animal));
                cout << "\033[32m\033[1mCongratulations! Your pet has reached adulthood! \033[0m" << endl;

                if (trainedAnimals.size() == 2) {
                    cout << "\033[1m\033[35mCongratulations, you already have 3 adult pets in your family!\033[0m" << endl;
                    for (const auto& pet : trainedAnimals) {
                        displayAnimalDetails(*pet);
                    }
                    exit(0);
                }

                if (getUserConfirmation("\033[1mDo you want to develop a new pet?\033[0m")) {
                    animal = Animal ("", "", "");
                    welcome();
                    animal = createAnimal();
                    continue;
                } else {
                    cout << "\033[1m\033[35mThank you, that's it for today.\033[0m" << endl;
                    exit(0);
                }
            }

            if(!getUserConfirmation("\033[1mDo you want to continue taking care of the animal\033[0m")) {
                cout << "\033[1m\033[35mThank you, that's all for today, see you.\033[0m" << endl;
                exit(0);
            }
        } while (true);
    }
    
    //Poniżej wytłumaczenie każdej linijki kodu:

    //void simulate(Animal& animal) - Definiuje funkcję simulate, która przyjmuje referencję do obiektu Animal jako argument. Użycie referencji pozwala na modyfikację obiektu animal bezpośrednio w funkcji.
    //string action - Deklaruje zmienną action, która będzie przechowywać akcję wprowadzoną przez użytkownika.
    //do { - Rozpoczyna pętlę do-while, która będzie kontynuowana, dopóki nie zostanie spełniony warunek wyjścia zdefiniowany na końcu tej pętli.
    //cout << "\033[4mPlease select the action you want to perform from the list below:\033[0m" << endl - Wyświetla komunikat zachęcający użytkownika do wybrania akcji. Używa sekwencji ucieczki \033[4m i \033[0m do zmiany stylu tekstu (tutaj podkreślenie).
    //for (const auto& act : actions) {
            cout << act << endl;
        } - Iteruje przez wektor actions, wyświetlając dostępne akcje. const auto& oznacza, że dla każdego elementu w actions tworzona jest referencja act, która jest niezmienialna (const).
    //cin >> action - Odbiera akcję wprowadzoną przez użytkownika i zapisuje ją do zmiennej action.
    //string lowerAction = toLower(action) - Przekształca wprowadzoną akcję na małe litery za pomocą funkcji toLower, ułatwiając jej dalsze porównywanie i obsługę.
    //animal.performAction(lowerAction) - Wywołuje metodę performAction obiektu animal, przekazując przekształconą akcję lowerAction.
    //animal.displayFeatures() - Wyświetla cechy obiektu animal po wykonaniu akcji.
    //if (animal.hasReachedAdulthood()) { - Sprawdza, czy zwierzę osiągnęło dorosłość, wywołując metodę hasReachedAdulthood.
    //trainedAnimals.push_back(make_shared<Animal>(animal)) - Jeśli zwierzę osiągnęło dorosłość, dodaje obiekt animal do wektora trainedAnimals jako shared_ptr. Użycie make_shared optymalizuje alokację pamięci.
    //cout << "\033[32m\033[1mCongratulations! Your pet has reached adulthood! \033[0m" << endl - Wyświetla gratulacje, używając sekwencji ucieczki do zmiany koloru i stylu tekstu.
    //if (trainedAnimals.size() == 2) { -  Sprawdza, czy rozmiar wektora trainedAnimals wynosi 3 (uwaga: w oryginalnym kodzie powinno być == 3 lub trzeba zmienić logikę komentarza/komunikatu). Oznacza to, że mamy już trzy wyszkolone zwierzęta.
    //cout << "\033[1m\033[35mCongratulations, you already have 3 adult pets in your family!\033[0m" << endl;
                for (const auto& pet : trainedAnimals) {
                    displayAnimalDetails(*pet);
                }
                exit(0); - Wyświetla informację o posiadaniu trzech dorosłych zwierząt i szczegóły każdego z nich. Następnie kończy działanie programu za pomocą exit(0).
    //if (getUserConfirmation("\033[1mDo you want to develop a new pet?\033[0m")) { - Pyta użytkownika, czy chce wychować nowe zwierzę. Tekst jest stylizowany przy użyciu sekwencji ucieczki.
    //animal = Animal("", "", "");
                welcome();
                animal = createAnimal();
                continue; - Resetuje obiekt animal i rozpoczyna proces tworzenia nowego zwierzęcia, a następnie kontynuuje pętlę.   
    //} else {
                cout << "\033[1m\033[35mThank you, that's it for today.\033[0m" << endl;
                exit(0);
            } - Jeśli użytkownik nie chce wychowywać nowego zwierzęcia, program wyświetla podziękowanie i kończy działanie.
    // if (!getUserConfirmation("\033[1mDo you want to continue taking care of the animal\033[0m")) {
            cout << "\033[1m\033[35mThank you, that's all for today, see you.\033[0m" << endl;
            exit(0);
        } - Pyta użytkownika, czy chce kontynuować opiekę nad zwierzęciem. Jeśli odpowiedź brzmi "nie", program wyświetla podziękowanie i kończy działanie.  
    //} while (true);   
    } - Pętla do-while kontynuuje działanie, dopóki nie zostanie spełniony żaden z warunków wyjścia (exit(0)).       



    //Metoda simulate przyjmuje referencję do obiektu Animal, co oznacza, że wszelkie zmiany dokonane na tym obiekcie wewnątrz metody będą miały wpływ na obiekt przekazany do metody. Dzięki użyciu referencji unika się kopiowania obiektu, co jest korzystne dla wydajności.
    // Po wybraniu akcji przez użytkownika, metoda performAction obiektu animal jest wywoływana z akcją jako argumentem. Ta metoda jest odpowiedzialna za zmianę stanu obiektu animal w zależności od akcji, np. zwiększenie cechy "happiness" po wybraniu akcji "play".
    // Na koniec, metoda displayFeatures obiektu animal jest wywoływana, aby pokazać zaktualizowany stan cech zwierzęcia po wykonaniu akcji. Jest to ważne dla użytkownika, aby zobaczyć efekt swoich działań.
    
    //Poniżej wyjaśnienie każdej lini kodu:

    // Definicja metody simulate, która przyjmuje referencję do obiektu klasy Animal
    void simulate(Animal& animal) {
    // Zmienna do przechowywania akcji wprowadzonej przez użytkownika
    string action;
    
    // Wyświetlenie komunikatu zachęcającego użytkownika do wyboru akcji
    cout << "Please select the action you want to perform from the list below:" << endl;
    
    // Pętla iterująca przez wektor dostępnych akcji i wyświetlająca je wszystkie
    for (const auto& act : actions) {
        // Wyświetlenie każdej możliwej akcji
        cout << act << endl;
    }
    
    // Odczytanie akcji wprowadzonej przez użytkownika
    cin >> action;
    
    // Konwersja wprowadzonej akcji na małe litery, aby zapewnić niezależność od wielkości liter
    string lowerAction = toLower(action);
    
    // Wywołanie metody performAction na obiekcie animal z akcją jako argumentem
    // Metoda ta zmienia cechy zwierzęcia w zależności od wykonanej akcji
    animal.performAction(lowerAction);
    
    // Wywołanie metody displayFeatures na obiekcie animal
    // Metoda ta wyświetla aktualne cechy zwierzęcia po wykonaniu akcji
    animal.displayFeatures();
    }

20. void displayAnimalDetails(const Animal &animal) {
        cout << "\033[1m" << endl << "Name: " << animal.name << endl << "Color: " << animal.colour << endl <<"Type: " << animal.type << endl << endl << "Trained features: \033[0m" << endl;
        for (const auto& feature : animal.features) {
            cout << feature.first << ": " << feature.second << endl;
        }
    }
};    

    //Poniżej wytłumaczenie każdej linijki kodu:
    //void displayAnimalDetails(const Animal &animal) { -Definicja funkcji displayAnimalDetails, która przyjmuje jako argument referencję do stałej (const) na obiekt Animal. Użycie const oznacza, że obiekt animal nie zostanie zmodyfikowany przez tę funkcję, a referencja umożliwia uniknięcie kopiowania, zapewniając jednocześnie bezpośredni dostęp do obiektu.
    //cout << "\033[1m" << endl << "Name: " << animal.name << endl << "Color: " << animal.colour << endl << "Type: " << animal.type << endl << endl << "Trained features: \033[0m" << endl; - Wyświetla informacje o zwierzęciu, w tym jego nazwę (name), kolor (colour), typ (type) oraz wprowadzenie do cech ("Trained features:"). Sekwencje \033[1m i \033[0m służą do włączenia i wyłączenia pogrubionego tekstu w terminalu. \033[1m włącza pogrubienie, a \033[0m powraca do standardowego stylu tekstu. Warto zauważyć, że działanie tych sekwencji zależy od terminala i może nie działać we wszystkich środowiskach.
    //for (const auto& feature : animal.features) { - Rozpoczyna pętlę, która iteruje przez każdą parę klucz-wartość (feature) w mapie features obiektu animal. const auto& oznacza, że dla każdego elementu w mapie tworzona jest referencja, która nie pozwala na modyfikację elementów, co jest wystarczające, ponieważ tylko wyświetlamy te informacje.
    //cout << feature.first << ": " << feature.second << endl - Dla każdej cechy (feature), wyświetla nazwę cechy (feature.first, czyli klucz w mapie) i jej wartość (feature.second, czyli wartość w mapie). Każda para klucz-wartość reprezentuje cechę zwierzęcia i jej poziom.
    // } - Zakończenie pętli for.
    // } - Zakończenie definicji funkcji displayAnimalDetails.

21. Do dodawania efektów specjalnych do tekstu wyświetlanego w terminalu, takich jak powiększenie liter, pogrubienie czy inne efekty, można użyć sekwencji ucieczki ANSI na systemach Unixowych, poniżej użyte przeze mnie:
    // Pogrubienie tekstu
    std::cout << "\033[1mThis text is bold!\033[0m" << std::endl;
    
    // Podkreślenie tekstu
    std::cout << "\033[4mThis text is underlined!\033[0m" << std::endl;

    // Czerwony tekst
    std::cout << "\033[31mThis text is red!\033[0m" << std::endl;
    
    // Zielony tekst
    std::cout << "\033[32mThis text is green!\033[0m" << std::endl;
    // Fioletowy tekst
    std::cout << "\033[35mThis text is purple!\033[0m" << std::endl;





W moim projekcie zdefiniowana jest klasa Animal zawierająca atrybuty przechowujące typ, nazwę i kolor zwierzęcia oraz mapę przechowującą cechy zwierzęcia i ich wartośći. Następnie zdefiniowany jest konstruktort klasy, inicjalizujący atrybuty i ustawiająca początkowe wartości cech.
Następnie metoda performAction jest zaprojektowana do obsługi różnych akcji, które mogą być wykonywane na obiekcie zwierzęcia, reprezentowanego przez klasę Animal. Dla każdej akcji takiej jak jedzenie, zabawa, mycie, spanie, głaskanie, metoda aktualizuje odpowiednie cechy zwierzęcia i wypisuje informację o wykonanej akcji oraz nowym stanie danej cechy.
Kolejna metoda wyświetla aktualne cechy zwierzęcia oraz infomacje o nim, takie jak imię, kolor, typ.
Stworzona jest kolejna klasa AnimalSumilator służąca do symulacji interakcji ze zwierzętami. Atrybuty w klasie to mapa animalDescription zawierająca opisy do poszczególnych typów zwierzęcia oraz wektor z listą możliwych akcji do wykonania na zwierzętach. Atrybuty posiadają specyfikator dostępu private w celu enkapsulacji oraz dobrej praktyki programistycznej. Dzięki temu można zmienić wewnętrzną implementację tych atrybutów bez wpływu na resztę programu. który korzysta z klasy AnimalSimulator. Obra wspomniane atrybuty umożliwiają wybór opcji z których użytkownik może wybierać podczas korzystania z symulatora.
Następnie został zdefiniowany konstrukor inicjalizujący (tak zwany domyślny ponieważ nie wymaga żadnych argumentów podczas tworzenia obiektu AnimalSimulator) opisy zwierząt i możliwe akcje do wykonania na zwierzęciu. Jego głównym celem jest ustawienie początkowych wartości dla atrybutów klasy (animalDescriptions i actions).
Kolejno stworzono metodą powialną welcome. 
Kolejna metoda createAnimal służy do tworzenia nowego zwierzęcia przez użytkownika.
Ostatnia metoda simulate w klasie AnimalSimulator służy do symulacji interakcji z obiektem Animal umożliwiając użytkownikowi wybór i wykonanie akcji, która wpłynie na cechy zwierzęcia. Metoda simulate jest przykładem interaktywnej części symulatora, która angażuje użytkownika w proces symulacji, pozwalając na dynamiczną zmianę stanu obiektu Animal i obserwowanie wyników tych zmian.
